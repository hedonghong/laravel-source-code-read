<?php

// autoload_real.php @generated by Composer
#防止用户自定义类名跟这个类重复冲突了，所以在类名上加了一个hash值
#为什么不用命名空间？可以用，但是getLoader源码中这个类只使用一次后便不再用了，暂且理解为不想浪费一个命名空间标识吧
class ComposerAutoloaderInitf98e46180a57e99b3e258e69ac1b8f28
{
    private static $loader;

    public static function loadClassLoader($class)
    {
        #防止用户也定义了个 \Composer\Autoload\ClassLoader 命名空间，导致自动加载错误文件
        if ('Composer\Autoload\ClassLoader' === $class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }

    public static function getLoader()
    {
        #单例模式，自动加载类只有一个哩
        if (null !== self::$loader) {
            return self::$loader;
        }
        #初始化自动加载类、注册自动加载类
        #向spl_autoload_register中注册自动加载处理类和函数，其中loadClassLoader本次的主角
        spl_autoload_register(array('ComposerAutoloaderInitf98e46180a57e99b3e258e69ac1b8f28', 'loadClassLoader'), true, true);
        #马上进行composer核心加载类的使用，该类才是真正的处理未加载外部文件的地方，设置核心加载类给self::$loader
        self::$loader = $loader = new \Composer\Autoload\ClassLoader();
        #注销spl_autoload_register中的loadClassLoader
        spl_autoload_unregister(array('ComposerAutoloaderInitf98e46180a57e99b3e258e69ac1b8f28', 'loadClassLoader'));

        #初始化自动加载核心类对象self::$loader

        #静态初始化只支持PHP5.6以上版本并且不支持HHVM虚拟机
        $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION');
        if ($useStaticLoader) {
            #使用autoload_static进行静态初始化
            require_once __DIR__ . '/autoload_static.php';
            #返回一个函数并且通过call_user_func调用，给$loader进行初始化ClassLoader类的一些私有变量，可以看src/Autoload/Src/autoload_static.php注释
            call_user_func(\Composer\Autoload\ComposerStaticInitf98e46180a57e99b3e258e69ac1b8f28::getInitializer($loader));
        } else {
            #调用核心类接口初始化
            #PSR0标准
            $map = require __DIR__ . '/autoload_namespaces.php';
            foreach ($map as $namespace => $path) {
                $loader->set($namespace, $path);
            }
            #PSR4标准
            $map = require __DIR__ . '/autoload_psr4.php';
            foreach ($map as $namespace => $path) {
                $loader->setPsr4($namespace, $path);
            }
            #直接命名空间对应目录映射关系ClassMap
            $classMap = require __DIR__ . '/autoload_classmap.php';
            if ($classMap) {
                $loader->addClassMap($classMap);
            }
        }

        #注册自动加载核心类对象，实际就是调用spl_autoload_register函数
        $loader->register(true);

        #自动加载全局函数
        #自动加载全局函数
        #全局函数自动加载也分为两种：静态初始化和普通初始化，静态加载只支持PHP5.6以上并且不支持HHVM。
        #vendor/composer/autoload_static.php的$files数组部分，认真看下就知道和autoload_files.php的一样
        if ($useStaticLoader) {
            $includeFiles = Composer\Autoload\ComposerStaticInitf98e46180a57e99b3e258e69ac1b8f28::$files;
        } else {
            $includeFiles = require __DIR__ . '/autoload_files.php';
        }
        #获取到全局函数文件数组后，循环一一加载
        foreach ($includeFiles as $fileIdentifier => $file) {
            #composerRequiref98e46180a57e99b3e258e69ac1b8f28这个代码就不说了，就是一个require
            #为什么不直接require而用composerRequiref98e46180a57e99b3e258e69ac1b8f28，原因是怕用户自定义的全局函数中使用了$this、self::
            #所以用类外的函数加载的时候，出现这种情况会报错给用户(真TM聪明啊)
            composerRequiref98e46180a57e99b3e258e69ac1b8f28($fileIdentifier, $file);
        }

        return $loader;
    }
}

function composerRequiref98e46180a57e99b3e258e69ac1b8f28($fileIdentifier, $file)
{
    if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {
        #require比require_once高效
        require $file;

        $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;
    }
}
